成员变量和局部变量。
作用范围。
成员变量作用于整个类中。
局部变量变量作用于函数中，或者语句中。
在内存中的位置：
成员变量：在堆内存中，因为对象的存在，才在内存中存在。
局部变量：存在栈内存中。



//匿名对象使用方式一：当对对象的方法只调用一次时，可以用匿名对象来完成，这样写比较简化。
//如果对一个对象进行多个成员调用，必须给这个对象起个名字。
//匿名对象使用方式二：可以将匿名对象作为实际参数进行传递。



对象一建立就会调用与之对应的构造函数。

构造函数的作用：可以用于给对象进行初始化。

构造函数的小细节：
当一个类中没有定义构造函数时，那么系统会默认给该类加入一个空参数的构造函数。
当在类中自定义了构造函数后，默认的构造函数就没有了。
构造函数和一般函数在写法上有不同。
在运行上也有不同。
构造函数是在对象一建立就运行。给对象初始化。
而一般方法是对象调用才执行，给是对象添加对象具备的功能。
一个对象建立，构造函数只运行一次。
而一般方法可以被该对象调用多次。
什么时候定义构造函数呢？
当分析事物时，该事物存在具备一些特性或者行为，那么将这些内容定义在构造函数中。
/*
一个类中默认会有一个空参数的构造函数，
这个默认的构造函数的权限和所属类一致。
如果类被public修饰，那么默认的构造函数也带public修饰符。
如果类没有被public修饰，那么默认的构造函数，也没有public修饰。

默认构造构造函数的权限是随着的类的变化而变化的。
*/
	构造代码块。
	作用：给对象进行初始化。
	对象一建立就运行，而且优先于构造函数执行。
	和构造函数的区别：
	构造代码块是给所有对象进行统一初始化，
	而构造函数是给对应的对象初始化。

	构造代码快中定义的是不同对象共性的初始化内容。

	*/



/*
this:看上去，是用于区分局部变量和成员变量同名情况。
this为什么可以解决这个问题？
this到底代表的是什么呢？

this：就代表本类的对象，到底代表哪一个呢？
	this代表它所在函数所属对象的引用。
	简单说：哪个对象在调用this所在的函数，this就代表哪个对象。


this的应用：当定义类中功能时，该函数内部要用到调用该函数的对象时，这时用this来表示这个对象。
		但凡本类功能内部使用了了本类对象，都用this表示。

*/


/*
this语句 :用于构造函数之间进行互相调用。

this语句只能定义在构造函数的第一行。因为初始化要先执行。
*/

/*
静态的应用。

每一个应用程序中都有共性的功能，
可以将这些功能进行抽取，独立封装。
以便复用。
*/

/*
1，java语法(变量，语句，函数，数组)，
2，面向对象(类和对象的关系，封装（机箱故事），继承，多态，构造函数，this，static，内部类，抽象类，接口)
3，多线程。
4，JavaApi（其实就是java给我们提供的已经定义好的对象。工具对象：集合框架）
5，输入输出(IO)
6，java的图形界面。--事件监听机制。
7，网络通讯。Socket
*/
/*
Person p = new Person("zhangsan",20);

该句话都做了什么事情？
1，因为new用到了Person.class.所以会先找到Person.class文件并加载到内存中。
2，执行该类中的static代码块，如果有的话，给Person.class类进行初始化。
3，在堆内存中开辟空间，分配内存地址。
4，在堆内存中建立对象的特有属性。并进行默认初始化。
5，对属性进行显示初始化。
6，对对象进行构造代码块初始化。
7，对对象进行对应的构造函数初始化。
8，将内存地址付给栈内存中的p变量。

*/
/*
设计模式：解决某一类问题最行之有效的方法。
java中23种设计模式：
单例设计模式：解决一个类在内存只存在一个对象。
想要保证对象唯一。
1，为了避免其他程序过多建立该类对象。先禁止其他程序建立该类对象
2，还为了让其他程序可以访问到该类对象，只好在本类中，自定义一个对象。
3，为了方便其他程序对自定义对象的访问，可以对外提供一些访问方式。

这三部怎么用代码体现呢？
1，将构造函数私有化。
2，在类中创建一个本类对象。
3，提供一个方法可以获取到该对象。
对于事物该怎么描述，还怎么描述。
当需要将该事物的对象保证在内存中唯一时，就将以上的三步加上即可。
*/

//对象是方法被调用时，才初始化，也叫做对象的延时加载。成为：懒汉式。

/*
静态代码块。
格式：
static
{
	静态代码块中的执行语句。
}

特点：随着类的加载而执行，只执行一次,并优先于主函数。
用于给类进行初始化的。

*/

/*
静态：static。
用法：是一个修饰符，用于修饰成员(成员变量，成员函数).
当成员被静态修饰后，就多了一个调用方式，除了可以被对象调用外，
还可以直接被类名调用。类名.静态成员。


static特点：
1，随着类的加载而加载。
   也就说：静态会随着类的消失而消失。说明它的生命周期最长。

2，优先于的对象存在
明确一点：静态是先存在。对象是后存在的。

3，被所有对象所共享
4，可以直接被类名所调用。

实例变量和类变量的区别：
1，存放位置。
	类变量随着类的加载而存在于方法区中。
	实例变量随着对象的建立而存在于堆内存中。
2，生命周期：
	类变量生命周期最长，随着类的消失而消失。
	实例变量生命周期随着对象的消失而消失。

静态使用注意事项：
1，静态方法只能访问静态成员。
	非静态方法既可以访问静态也可以访问非静态。
2，静态方法中不可以定义this，super关键字。
	因为静态优先于对象存在。所以静态方法中不可以出现this。
3，主函数是静态的。
	
静态有利有弊
利处：对对象的共享数据进行单独空间的存储，节省空间。没有必要每一个对象中都存储一份。
	可以直接被类名调用。
弊端：生命周期过长。
	  访问出现局限性。(静态虽好，只能访问静态。)
*/

/*
什么使用静态？

要从两方面下手：
因为静态修饰的内容有成员变量和函数。
什么时候定义静态变量(类变量)呢？
当对象中出现共享数据时，该数据被静态所修饰。
对象中的特有数据要定义成非静态存在于堆内存中。

什么时候定义静态函数呢？

当功能内部没有访问到非静态数据(对象的特有数据)，
那么该功能可以定义成静态的。

*/

/*
当多个类中出现相同功能，但是功能主体不同，
这是可以进行向上抽取。这时，只抽取功能定义，而不抽取功能主体。

抽象：看不懂。

抽象类的特点：
1，抽象方法一定在抽象类中。
2，抽象方法和抽象类都必须被abstract关键字修饰。
3，抽象类不可以用new创建对象。因为调用抽象方法没意义。
4，抽象类中的抽象方法要被使用，必须由子类复写起所有的抽象方法后，建立子类对象调用。
	如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。


抽象类和一般类没有太大的不同。
该如何描述事物，就如何描述事物，只不过，该事物出现了一些看不懂的东西。
这些不确定的部分，也是该事物的功能，需要明确出现。但是无法定义主体。
通过抽象方法来表示。

抽象类比一般类多个了抽象函数。就是在类中可以定义抽象方法。
抽象类不可以实例化。


特殊：抽象类中可以不定义抽象方法，这样做仅仅是不让该类建立对象。


练习：

abstract 关键字，和哪些关键字不能共存。
final：被final修饰的类不能有子类。而被abstract修饰的类一定是一个父类。
private: 抽象类中的私有的抽象方法，不被子类所知，就无法被复写。
		而抽象方法出现的就是需要被复写。
static：如果static可以修饰抽象方法，那么连对象都省了，直接类名调用就可以了。
		可是抽象方法运行没意义。



抽象类中是否有构造函数？
有，抽象类是一个父类，要给子类提供实例的初始化。

*/

/*
 继承：
1，提高了代码的复用性。
2，让类与类之间产生了关系。有了这个关系，才有了多态的特性。


注意：千万不要为了获取其他类的功能，简化代码而继承。
必须是类与类之间有所属关系才可以继承。所属关系 is a。
*/
/*
子父类出现后，类成员的特点：

类中成员：
1，变量。
2，函数。
3，构造函数。

1,变量
如果子类中出现非私有的同名成员变量时，
子类要访问本类中的变量，用this
子类要访问父类中的同名变量，用super。

super的使用和this的使用几乎一致。
this代表的是本类对象的引用。
super代表的是父类对象的引用。
*/
/*
2,子父类中的函数。

当子类出现和父类一模一样的函数时，
当子类对象调用该函数，会运行子类函数的内容。
如同父类的函数被覆盖一样。

这种情况是函数的另一个特性：重写(覆盖)

当子类继承父类，沿袭了父类的功能，到子类中，
但是子类虽具备该功能，但是功能的内容却和父类不一致，
这时，没有必要定义新功能，而是使用覆盖特殊，保留父类的功能定义，并重写功能内容。


覆盖：
1，子类覆盖父类，必须保证子类权限大于等于父类权限，才可以覆盖，否则编译失败。
2，静态只能覆盖静态。


记住大家：
重载：只看同名函数的参数列表。
重写：子父类方法要一模一样。
*/

/*
3，子父类中的构造函数。

在对子类对象进行初始化时，父类的构造函数也会运行，
那是因为子类的构造函数默认第一行有一条隐式的语句 super();
super():会访问父类中空参数的构造函数。而且子类中所有的构造函数默认第一行都是super();

为什么子类一定要访问父类中的构造函数。

因为父类中的数据子类可以直接获取。所以子类对象在建立时，需要先查看父类是如何对这些数据进行初始化的。
所以子类在对象初始化时，要先访问一下父类中的构造函数。
如果要访问父类中指定的构造函数，可以通过手动定义super语句的方式来指定。

注意：super语句一定定义在子类构造函数的第一行。

子类的实例化过程。

结论：
子类的所有的构造函数，默认都会访问父类中空参数的构造函数。
因为子类每一个构造函数内的第一行都有一句隐式super();

当父类中没有空参数的构造函数时，子类必须手动通过super语句形式来指定要访问父类中的构造函数。

当然：子类的构造函数第一行也可以手动指定this语句来访问本类中的构造函数。
子类中至少会有一个构造函数会访问父类中的构造函数。
*/

/*
final : 最终。作为一个修饰符，
1，可以修饰类，函数，变量。
2，被final修饰的类不可以被继承。为了避免被继承，被子类复写功能。
3，被final修饰的方法不可以被复写。
4，被final修饰的变量是一个常量只能赋值一次，既可以修饰成员变量，有可以修饰局部变量。
	当在描述事物时，一些数据的出现值是固定的，那么这时为了增强阅读性，都给这些值起个名字。方便于阅读。
	而这个值不需要改变，所以加上final修饰。作为常量：常量的书写规范所有字母都大写，如果由多个单词组成。
	单词间通过_连接。
5，内部类定义在类中的局部位置上是，只能访问该局部被final修饰的局部变量。

*/

/*
接口：初期理解，可以认为是一个特殊的抽象类
	当抽象类中的方法都是抽象的，那么该类可以通过接口的形式来表示。
class用于定义类
interface 用于定义接口。

接口定义时，格式特点：
1，接口中常见定义：常量，抽象方法。
2，接口中的成员都有固定修饰符。
	常量：public static final
	方法：public abstract 
记住：接口中的成员都是public的。


接口：是不可以创建对象的，因为有抽象方法。
需要被子类实现，子类对接口中的抽象方法全都覆盖后，子类才可以实例化。
否则子类是一个抽象类。

接口可以被类多实现，也是对多继承不支持的转换形式。java支持多实现。


*/


/*
多态：可以理解为事物存在的多种体现形态。

人：男人，女人

动物：猫，狗。

猫 x = new 猫();

动物 x = new 猫();

1，多态的体现
	父类的引用指向了自己的子类对象。
	父类的引用也可以接收自己的子类对象。
2，多态的前提
	必须是类与类之间有关系。要么继承，要么实现。
	通常还有一个前提：存在覆盖。

3，多态的好处
	多态的出现大大的提高程序的扩展性。

4，多态的弊端：
	提高了扩展性，但是只能使用父类的引用访问父类中的成员。
*/
/*
在多态中成员函数的特点：
在编译时期：参阅引用型变量所属的类中是否有调用的方法。如果有，编译通过，如果没有编译失败。
在运行时期：参阅对象所属的类中是否有调用的方法。
简单总结就是：成员函数在多态调用时，编译看左边，运行看右边。


在多态中，成员变量的特点：
无论编译和运行，都参考左边(引用型变量所属的类)。


在多态中，静态成员函数的特点：
无论编译和运行，都参考做左边。

多态总结：：：：：：：：：：：：：：
一。表现：
父类或者接口的引用指向了或者接收了自己的子类对象。

二。前提：
1，类与类之间要有关系。继承，实现。
2，通常都会有覆盖。

三。好处：
预先定义的程序可以运行后期程序的内容。
增强了程序的扩展性。

四。弊端：
虽然可以预先使用，但是只能访问父类中已有的功能，运行的是后期子类的功能内容。
不能预先使用子类中定义的特有功能。

五。多态的注意事项：
在代码中。
对于成员函数：Fu f = new Zi(); f.method();
编译时期：看左边。
运行时期：看右边。
因为成员函数有一个覆盖操作。
	毕姥爷和毕老师的故事。

	
对于非私有的实例变量，
静态变量，静态方法。

编译和运行都看左边。

老师要求记住结论。有空闲时间，就想想为什么？

六。转型。
子类对象被父类引用：子类对象在向上转型。
将指向子类对象的父类应用转换成子类类型引用：向下转型。

*/

面向对象小总结：
继承：
	特点：
		1，提高了代码的复用性。
		2，让类与类之间产生关系，是多态性的前提。

	Java中的继承。
		1，java只支持单继承，不支持多继承。为啥呢？答案：因为继承了多个父类如果有相同方法时，
												子类对象不确定运行哪一个。
		2，Java还支持多层继承。A-->B--->C  原来可以形成继承体系。
			想要使用体系功能，"查阅父类功能，建立子类对象调用功能。"
			注解：父类的由来其实是由事物中的共性内容不断向上抽取而来的。
				所以父类中定义的是该体系中的最基本，最共性功能。
	
	继承出现后，代码上也有一些特点：
	1，变量。
		当子父类中定义了相同的名称的成员变量，
		子类要使用父类中的同名变量时，需要使用关键字super来区分。
		一般不会出现这种情况，因为父类中有了，子类不需要定义。
		而且父类定义时，一般变量都私有化。

	2，函数。
		子类可以直接访问父类中非私有的成员函数。
		特殊情况：当子类中定义了与父类一模一样的方法时，会发生覆盖操作。大多指的是非静态方法。
				  最终会运行子类的方法，父类相当于被覆盖了。
				  函数的另一个特性：覆盖（重写，复写）。
				  什么时候用啊？
				  当父类的功能要被修改时，不建议修改源码。因为是灾难。
				  只要通过一个类继承原有类，定义一个新的升级后的功能即可。
				  但是功能是相同的，只是实现方法改变。这是子类可以沿袭父类中的功能定义，
				  并重写功能内容。这就是覆盖。

				  覆盖很爽，但是有注意事项：
				  1，子类覆盖父类时，必须权限要大于等于父类权限。
				  2，静态不能覆盖非静态。
			
	3，构造函数。
		构造函数可以本类进行对象初始化，也可以给子类对象进行初始化。
		子类对象初始化过程：
		子类中的所有构造方法都会访问父类中空参数的构造函数，
		因为每一个构造函数的第一行，都有一句隐式的super语句。
		为什么要有这条语句？
		因为子类会获取到父类中的数据，必须要先明确父类对数据的初始化过程。

		当父类中没有空参数构造函数时，子类构造函数必须通过super句来明确要访问的父类中指定的构造函数。

		当时子类构造函数也可以通过this语句访问本类中的构造函数。
		但是子类中肯定，至少有一个构造函数会访问父类。

	
抽象类：其实就是在分析事物时，事物中的功能有些是不明确的内容的。这些不明确内容就是抽象的。
		可以通过抽象函数来描述。

		抽象函数一定要定义在抽象类中，因为，抽象函数所在类，也必须被抽象标识。

		写法特点：
		1，抽象函数只对函数进行声明，没有函数主体。
		2，抽象类和抽象函数都需要用abstract修饰。
		3，抽象类不可以进行实例化。
		4，想要使用抽象功能，必须通过子类覆盖了父类中所有的抽象方法后，才可以对子类实例化。
			如果只覆盖了部分抽象方法，那么子类还是一个抽象类。

		也可以理解为：抽象类是一个父类，是不断向上抽取而来的，
		在抽取过程中，只抽取了方法声明，但没有抽取方法实现。

		抽象类和一半类差不多。
		区别：
		抽象类可以定义抽象方法。
		抽象类不可以建立对象。

		其实抽象类一样用于描述事物，既可以定义抽象方法，也可以定义非抽象方法。


	

接口
	 初期理解：接口看上去是一个特殊的抽象类。里面存的都是抽象方法。

	 特点：
	 格式：
		1，通过interface来定义。
		2，接口中常见成员：常量，抽象方法。
			而且这些成员都有固定的修饰符。
			常量：public static final
			方法：public abstract 
		3，接口中的成员都是共有的。
		4，一个类可以对接口进行多实现，也弥补了多继承带来的安全隐患，所以java对多继承进行了改良。
			用多实现方法来体现多继承的特性。
		5，一个类可以继承一个类的同时，实现多个接口。
		6，接口与接口之间是继承关系，而且可以多继承。


	应用特点：
		1，接口是对外暴露的规则。
		2，接口是功能的扩展。
		3，接口的出现降低了耦合性。
		别忘了说的时候，需要举例。如usb。pci，主板。插座。


抽象类和接口异同：
相同：
1，都可以在内部定义抽象方法。
2，通常都在顶层。
3，都不可以实例化，都需要子类来实现。

不同点：
1，抽象类中可以定义抽象方法和非抽象方法，
	而接口中只能定义抽象方法。
2，接口的出现可以多实现。
	抽象类只能单继承。
	也就是说：接口的出现避免了单继承的局限性。
3，继承和实现的关系不一致。继承：is a，实现：like a 
*/

/*
异常：就是程序在运行时出现不正常情况。
异常由来：问题也是现实生活中一个具体的事物，也可以通过java的类的形式进行描述。并封装成对象。
			其实就是java对不正常情况进行描述后的对象体现。

对于问题的划分：两种：一种是严重的问题，一种非严重的问题。

对于严重的，java通过Error类进行描述。
	对于Error一般不编写针对性的代码对其进行处理。

对与非严重的，java通过Exception类进行描述。
	对于Exception可以使用针对性的处理方式进行处理。

无论Error或者Exception都具有一些共性内容。
比如：不正常情况的信息，引发原因等。

Throwable
	|--Error
	|--Exception




2,异常的处理

java 提供了特有的语句进行处理。
try
{
	需要被检测的代码；
}
catch(异常类 变量)
{
	处理异常的代码；(处理方式)
}
finally
{
	一定会执行的语句；
}

3，对捕获到的异常对象进行常见方法操作。
	String getMessage()：获取异常信息。
在函数上声明异常。
便于提高安全性，让调用出进行处理。不处理编译失败。

对多异常的处理。

1，声明异常时，建议声明更为具体的异常。这样处理的可以更具体。
2，对方声明几个异常，就对应有几个catch块。不要定义多余的catch块。
	如果多个catch块中的异常出现继承关系，父类异常catch块放在最下面。


建立在进行catch处理时，catch中一定要定义具体处理方式。
不要简单定义一句 e.printStackTrace(),
也不要简单的就书写一条输出语句。

*/

/*
因为项目中会出现特有的问题，
而这些问题并未被java所描述并封装对象。
所以对于这些特有的问题可以按照java的对问题封装的思想。
将特有的问题。进行自定义的异常封装。

自定义异常。

需求：在本程序中，对于除数是-1，也视为是错误的是无法进行运算的。
那么就需要对这个问题进行自定义的描述。

当在函数内部出现了throw抛出异常对象，那么就必须要给对应的处理动作。
要么在内部try catch处理。
要么在函数上声明让调用者处理。

一般情况在，函数内出现异常，函数上需要声明。


发现打印的结果中只有异常的名称，却没有异常的信息。
因为自定义的异常并未定义信息。

如何定义异常信息呢？
因为父类中已经把异常信息的操作都完成了。
所以子类只要在构造时，将异常信息传递给父类通过super语句。
那么就可以直接通过getMessage方法获取自定义的异常信息。

自定义异常：
必须是自定义类继承Exception。

继承Exception原因：
异常体系有一个特点：因为异常类和异常对象都被抛出。
他们都具备可抛性。这个可抛性是Throwable这个体系中独有特点。

只有这个体系中的类和对象才可以被throws和throw操作。

throws和throw的区别
throws使用在函数上。
throw使用在函数内。

throws后面跟的异常类。可以跟多个。用逗号隔开。
throw后跟的是异常对象。

*/
class FuShuException extends Exception //getMessage();
{
	private int value;

	FuShuException()
	{
		super();
	}
	FuShuException(String msg,int value)
	{
		super(msg);
		this.value = value;
	}

	public int getValue()
	{
		return value;
	}

}
class Demo
{
	int div(int a,int b)throws FuShuException
	{
		if(b<0)
			throw new FuShuException("出现了除数是负数的情况------ / by fushu",b);//手动通过throw关键字抛出一个自定义异常对象。

		return a/b;
	}
}
class  ExceptionDemo3
{
	public static void main(String[] args) 
	{
		Demo d = new Demo();
		try
		{
			int x = d.div(4,-9);
			System.out.println("x="+x);		
		}
		catch (FuShuException e)
		{
			System.out.println(e.toString());
			//System.out.println("除数出现负数了");
			System.out.println("错误的负数是："+e.getValue());
		}		
		System.out.println("over");
	}
}
*/

/*
Exceptoin中有一个特殊的子类异常RuntimeException 运行时异常。

如果在函数内容抛出该异常，函数上可以不用声明，编译一样通过。

如果在函数上声明了该异常。调用者可以不用进行处理。编译一样通过；

之所以不用在函数声明，是因为不需要让调用者处理。
当该异常发生，希望程序停止。因为在运行时，出现了无法继续运算的情况，希望停止程序后，
对代码进行修正。

自定义异常时：如果该异常的发生，无法在继续进行运算，
就让自定义异常继承RuntimeException。

对于异常分两种：
1，编译时被检测的异常。
	
2，编译时不被检测的异常(运行时异常。RuntimeException以及其子类)

/*
异常在子父类覆盖中的体现；
1，子类在覆盖父类时，如果父类的方法抛出异常，那么子类的覆盖方法，只能抛出父类的异常或者该异常的子类。
2，如果父类方法抛出多个异常，那么子类在覆盖该方法时，只能抛出父类异常的子集。
3，如果父类或者接口的方法中没有异常抛出，那么子类在覆盖方法时，也不可以抛出异常。
	如果子类方法发生了异常。就必须要进行try处理。绝对不能抛。

*/

*/


/*
内部类的访问规则：
1，内部类可以直接访问外部类中的成员，包括私有。
	之所以可以直接访问外部类中的成员，是因为内部类中持有了一个外部类的引用，格式 外部类名.this
2，外部类要访问内部类，必须建立内部类对象。

访问格式：
1,当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中。
可以直接建立内部类对象。
格式
	外部类名.内部类名  变量名 = 外部类对象.内部类对象;
	Outer.Inner in = new Outer().new Inner();

2,当内部类在成员位置上，就可以被成员修饰符所修饰。
	比如，private：将内部类在外部类中进行封装。
		static:内部类就具备static的特性。
		当内部类被static修饰后，只能直接访问外部类中的static成员。出现了访问局限。

		在外部其他类中，如何直接访问static内部类的非静态成员呢？
		new Outer.Inner().function();

		在外部其他类中，如何直接访问static内部类的静态成员呢？
		uter.Inner.function();

	注意：当内部类中定义了静态成员，该内部类必须是static的。
		  当外部类中的静态方法访问内部类时，内部类也必须是static的。
	
当描述事物时，事物的内部还有事物，该事物用内部类来描述。
因为内部事务在使用外部事物的内容。
class Body
{
	private class XinZang
	{

	}

	public void show()
	{
		new XinZang().
	}
	
}
内部类定义在局部时，
1，不可以被成员修饰符修饰
2，可以直接访问外部类中的成员，因为还持有外部类中的引用。
	但是不可以访问它所在的局部中的变量。只能访问被final修饰的局部变量。
 */
/*	
匿名内部类:
1，匿名内部类其实就是内部类的简写格式。
2，定义匿名内部类的前提：
	内部类必须是继承一个类或者实现接口。
3，匿名内部类的格式：  new 父类或者接口(){定义子类的内容}
4，其实匿名内部类就是一个匿名子类对象。而且这个对象有点胖。	可以理解为带内容的对象。
5，匿名内部类中定义的方法最好不要超过3个。
*/

/*
为什么要覆盖run方法呢？

Thread类用于描述线程。
该类就定义了一个功能，用于存储线程要运行的代码。该存储功能就是run方法。

也就是说Thread类中的run方法，用于存储线程要运行的代码。

////
如果同步函数被静态修饰后，使用的锁是什么呢？

通过验证，发现不在是this。因为静态方法中也不可以定义this。

静态进内存是，内存中没有本类对象，但是一定有该类对应的字节码文件对象。
类名.class  该对象的类型是Class


静态的同步方法，使用的锁是该方法所在类的字节码文件对象。 类名.class

同步函数用的是哪一个锁呢？
函数需要被对象调用。那么函数都有一个所属对象引用。就是this。
所以同步函数使用的锁是this。

同步代码块。

synchronized(对象)
{
	需要被同步的代码

}
对象如同锁。持有锁的线程可以在同步中执行。
没有持有锁的线程即使获取cpu的执行权，也进不去，因为没有获取锁。

火车上的卫生间---经典。

同步的前提：
1，必须要有两个或者两个以上的线程。
2，必须是多个线程使用同一个锁。

必须保证同步中只能有一个线程在运行。


好处：解决了多线程的安全问题。

弊端：多个线程需要判断锁，较为消耗资源，
同步的表现形式：
1，同步代码块。
2，同步函数。
两者有什么不同：
同步代码块使用的锁是任意对象。
同步函数使用的锁是this。


注意：对于static的同步函数，使用的锁不是this。是 类名.class 是该类的字节码文件对象。
	涉及到了单例设计模式的懒汉式。


同步的好处：解决了线程的安全问题。

弊端：
	较为消耗资源。
	同步嵌套后，容易死锁。

要记住：同步使用的前提：
	1，必须是两个或者两个以上的线程。
	2，必须是多个线程使用同一个锁。
	这是才可以称为这些线程被同步了。

死锁代码一定会写。但开发时一定注意避免。

*/
/*
对于多个生产者和消费者。
为什么要定义while判断标记。
原因：让被唤醒的线程再一次判断标记。


为什么定义notifyAll，
因为需要唤醒对方线程。
因为只用notify，容易出现只唤醒本方线程的情况。导致程序中的所有线程都等待。

*/
*/
*
wait:
notify();
notifyAll();

都使用在同步中，因为要对持有监视器(锁)的线程操作。
所以要使用在同步中，因为只有同步才具有锁。

为什么这些操作线程的方法要定义Object类中呢？
因为这些方法在操作同步中线程时，都必须要标识它们所操作线程只有的锁，
只有同一个锁上的被等待线程，可以被同一个锁上notify唤醒。
不可以对不同锁中的线程进行唤醒。

也就是说，等待和唤醒必须是同一个锁。

而锁可以是任意对象，所以可以被任意对象调用的方法定义Object类中。

/*
JDK1.5 中提供了多线程升级解决方案。
将同步Synchronized替换成现实Lock操作。
将Object中的wait，notify notifyAll，替换了Condition对象。
该对象可以Lock锁 进行获取。
该示例中，实现了本方只唤醒对方操作。

Lock:替代了Synchronized
	lock 
	unlock
	newCondition()

Condition：替代了Object wait notify notifyAll
	await();
	signal();
	signalAll();
*/

join:
当A线程执行到了B线程的.join()方法时，A就会等待。等B线程都执行完，A才会执行。

join可以用来临时加入线程执行。
如何停止线程？
只有一种，run方法结束。
开启多线程运行，运行代码通常是循环结构。

只要控制住循环，就可以让run方法结束，也就是线程结束。


特殊情况：
当线程处于了冻结状态。
就不会读取到标记。那么线程就不会结束。

当没有指定的方式让冻结的线程恢复到运行状态是，这时需要对冻结进行清除。
强制让线程恢复到运行状态中来。这样就可以操作标记让线程结束。

Thread类提供该方法 interrupt();

*/


